---
title: "Introduction"
description: "Package w3 implements a blazing fast and modular Ethereum JSON RPC client with first-class ABI support."
---

<div class="flex space-x-1 flex-wrap">
  <a
    class="border-none my-0.5"
    href="https://pkg.go.dev/github.com/lmittmann/w3"
  >
    <img
      class="m-0"
      src="https://pkg.go.dev/badge/github.com/lmittmann/w3.svg"
      alt="Go Reference"
    />
  </a>
  <a
    class="border-none my-0.5"
    href="https://goreportcard.com/report/github.com/lmittmann/w3"
  >
    <img
      class="m-0"
      src="https://goreportcard.com/badge/github.com/lmittmann/w3"
      alt="Go Report Card"
    />
  </a>
  <a
    class="border-none my-0.5"
    href="https://coveralls.io/github/lmittmann/w3?branch=main"
  >
    <img
      class="m-0"
      src="https://coveralls.io/repos/github/lmittmann/w3/badge.svg?branch=main"
      alt="Coverage Status"
    />
  </a>
  <a class="border-none my-0.5" href="https://github.com/lmittmann/w3/releases">
    <img
      class="m-0"
      src="https://img.shields.io/github/v/release/lmittmann/w3"
      alt="Latest Release"
    />
  </a>
</div>

<img
  src="https://user-images.githubusercontent.com/3458786/153202258-24bf253e-5ab0-4efd-a0ed-43dc1bf093c9.png"
  align="right"
  alt="W3 Gopher"
  width="158"
  height="224"
/>

- **Batch request** support significantly reduces the duration of requests to
  both remote and local endpoints.
- **ABI** bindings are specified for individual functions using Solidity syntax.
  No need for `abigen` and ABI JSON files.
- **Modular** API allows to create custom RPC method integrations that can be
  used alongside the methods implemented by the package.

`w3` is closely linked to [go-ethereum](https://github.com/ethereum/go-ethereum)
and uses a variety of its types, such as [`common.Address`](https://pkg.go.dev/github.com/ethereum/go-ethereum/common#Address)
or [`types.Transaction`](https://pkg.go.dev/github.com/ethereum/go-ethereum/core/types#Transaction).

Batch requests with `w3` are up to **85x faster** than sequential requests with
`go-ethereum/ethclient`.

<Accordion title="Benchmarks" icon="chart-mixed" iconType="solid">

```
name ethclient time/op w3 time/op delta Call_BalanceNonce 78.3ms ± 2% 39.0ms
± 1% -50.15% (p=0.000 n=23+22) Call_Balance100 3.90s ± 5% 0.05s ± 2% -98.84%
(p=0.000 n=20+24) Call_BalanceOf100 3.99s ± 3% 0.05s ± 2% -98.73% (p=0.000
n=22+23) Call_Block100 6.89s ± 7% 1.94s ±11% -71.77% (p=0.000 n=24+23)
```

</Accordion>

## Install

```bash
go get github.com/lmittmann/w3
```

## Getting Started

> **Note**
> Check out the [examples](examples/)!

Connect to an RPC endpoint via HTTP, WebSocket, or IPC using [`Dial`](https://pkg.go.dev/github.com/lmittmann/w3#Dial)
or [`MustDial`](https://pkg.go.dev/github.com/lmittmann/w3#MustDial).

```go
// Connect (or panic on error)
client := w3.MustDial("https://rpc.ankr.com/eth")
defer client.Close()
```

## Batch Requests

Batch request support in the [`Client`](https://pkg.go.dev/github.com/lmittmann/w3#Client)
allows to send multiple RPC requests in a single HTTP request. The speed gains
to remote endpoints are huge. Fetching 100 blocks in a single batch request
with `w3` is ~80x faster compared to sequential requests with `ethclient`.

Example: Request the nonce and balance of an address in a single request

```go
var (
	addr = w3.A("0x000000000000000000000000000000000000c0Fe")

	nonce   uint64
	balance big.Int
)
err := client.Call(
	eth.Nonce(addr, nil).Returns(&nonce),
	eth.Balance(addr, nil).Returns(&balance),
)
```

## ABI Bindings

ABI bindings in `w3` are specified for individual functions using Solidity
syntax and are usable for any contract that supports that function.

Example: ABI binding for the ERC20-function `balanceOf`

```go
funcBalanceOf := w3.MustNewFunc("balanceOf(address)", "uint256")
```

A [`Func`](https://pkg.go.dev/github.com/lmittmann/w3#Func) can be used to

- encode arguments to the contracts input data ([`Func.EncodeArgs`](https://pkg.go.dev/github.com/lmittmann/w3#Func.EncodeArgs)),
- decode arguments from the contracts input data ([`Func.DecodeArgs`](https://pkg.go.dev/github.com/lmittmann/w3#Func.DecodeArgs)), and
- decode returns form the contracts output data ([`Func.DecodeReturns`](https://pkg.go.dev/github.com/lmittmann/w3#Func.DecodeReturns)).

### Reading Contracts

[`Func`](https://pkg.go.dev/github.com/lmittmann/w3#Func)'s can be used with
[`eth.CallFunc`](https://pkg.go.dev/github.com/lmittmann/w3/module/eth#CallFunc)
in the client to read contract data.

```go
var (
	weth9 = w3.A("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2")
	dai   = w3.A("0x6B175474E89094C44Da98b954EedeAC495271d0F")

	weth9Balance big.Int
	daiBalance   big.Int
)

err := client.Call(
	eth.CallFunc(funcBalanceOf, weth9, addr).Returns(&weth9Balance),
	eth.CallFunc(funcBalanceOf, dai, addr).Returns(&daiBalance),
)
```

### Writing Contracts

Sending a transaction to a contract requires three steps.

1. Encode the transaction input data using [`Func.EncodeArgs`](https://pkg.go.dev/github.com/lmittmann/w3#Func.EncodeArgs).

```go
var funcTransfer = w3.MustNewFunc("transfer(address,uint256)", "bool")

input, err := funcTransfer.EncodeArgs(w3.A("0x…"), w3.I("1 ether"))
```

2. Create a signed transaction to the contract using [go-ethereum/types](https://github.com/ethereum/go-ethereum).

```go
signer := types.LatestSigner(params.MainnetChainConfig)
tx := types.MustSignNewTx(privKey, signer, &types.DynamicFeeTx{
	To:        w3.A("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"),
	Nonce:     0,
	Data:      input,
	Gas:       75000,
	GasFeeCap: w3.I("100 gwei"),
	GasTipCap: w3.I("1 gwei"),
})
```

3. Send the signed transaction.

```go
var txHash common.Hash
err := client.Call(
	eth.SendTx(tx).Returns(&txHash),
)
```
